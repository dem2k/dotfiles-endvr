#!/usr/bin/bash

# ==========[ DDD - DD mit Dialog ]===========

# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚ Einfacher Wrapper fÃ¼r dd mit Fortschritts-   â”‚
# â”‚ anzeige via dialog --gauge                   â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

# PrÃ¼fen, ob das Skript in einem Terminal lÃ¤uft
if [[ ! -t 0 || ! -t 1 ]]; then
  echo "âŒ Fehler: Dieses Skript muss in einem Terminal ausgefÃ¼hrt werden."
  echo "   Bitte Ã¶ffne ein Terminal und fÃ¼hre das Skript dort aus."
  exit 1
fi

# Parameter parsen
while [[ $# -gt 0 ]]; do
  case "$1" in
    -if)
      SOURCE="$2"
      shift 2
      ;;
    -of)
      DEST="$2"
      shift 2
      ;;
    *)
      echo "Unbekannter Parameter: $1"
      echo "Benutzung: ddd -if <inputfile> [-of <outputdevice>]"
      exit 1
      ;;
  esac
done

# Validierung: Input-Datei
if [[ -z "$SOURCE" ]]; then
  echo "âŒ Fehler: -if (Input-Datei) muss angegeben werden."
  exit 1
fi
 
if [[ ! -f "$SOURCE" ]]; then
  echo "âŒ Fehler: Input-Datei '$SOURCE' existiert nicht."
  exit 1
fi

# Wenn -of fehlt â†’ interaktive Auswahl anzeigen
if [[ -z "$DEST" ]]; then
  DISKS=()
  for devpath in /dev/sd?; do
    if [[ -b "$devpath" ]]; then
      devname=$(basename "$devpath")
      # GrÃ¶ÃŸe in Bytes â†’ formatiert
      SIZE=$(lsblk -b -dn -o SIZE "$devpath" 2>/dev/null)
      SIZE_H=$(numfmt --to=iec-i --suffix=B "$SIZE")
      # Vendor, Model und Label mit udevadm
      VENDOR=$(udevadm info --query=all --name="$devpath" 2>/dev/null | grep "ID_VENDOR=" | cut -d= -f2)
      MODEL=$(udevadm info --query=all --name="$devpath" 2>/dev/null | grep "ID_MODEL=" | cut -d= -f2)
      # Label von der ersten Partition holen
      LABEL=$(lsblk -n -o LABEL "${devpath}1" 2>/dev/null | head -1 | tr -d '[:space:]')
      
      [[ -z "$VENDOR" ]] && VENDOR="Unbekannt"
      [[ -z "$MODEL" ]] && MODEL="Unbekannt"
      [[ -z "$LABEL" ]] && LABEL="(kein Label)"
      
      # Label fÃ¼r dialog menu mit column formatiert
      DISKS+=("$devpath" "${SIZE_H}; ${VENDOR}; ${MODEL}; ${LABEL}")
    fi
  done

  if [[ ${#DISKS[@]} -eq 0 ]]; then
    echo "âŒ Keine geeigneten ZielgerÃ¤te gefunden (z.B. /dev/sdX)."
    exit 1
  fi

# # DISKS Array mit column formatieren (alle Labels zusammen)
#   TEMP_FILE=$(mktemp)
#   for ((i=1; i<${#DISKS[@]}; i+=2)); do
#     echo "${DISKS[$i]}" >> "$TEMP_FILE"
#   done
#   
#   FORMATTED_LABELS=($(column -ts';' "$TEMP_FILE"))
#   cat $TEMP_FILE|column -ts';'
#   rm -f "$TEMP_FILE"
#   echo $FORMATTED_LABELS
#   exit
#   
#   # Neues Array mit formatierten Labels erstellen
#   FORMATTED_DISKS=()
#   label_idx=0
#   for ((i=0; i<${#DISKS[@]}; i+=2)); do
#     FORMATTED_DISKS+=("${DISKS[$i]}" "${FORMATTED_LABELS[$label_idx]}")
#     ((label_idx++))
#   done
#   DISKS=("${FORMATTED_DISKS[@]}")

  # # DISKS Array mit column formatieren
  # FORMATTED_DISKS=()
  # for ((i=0; i<${#DISKS[@]}; i+=2)); do
  #   devpath="${DISKS[$i]}"
  #   label=$(echo "${DISKS[$i+1]}" | column -ts';')
  #   FORMATTED_DISKS+=("$devpath" "$label")
  # done
  # DISKS=("${FORMATTED_DISKS[@]}")
  
  # Dialog-MenÃ¼ anzeigen
  DEST=$(dialog --clear --title "ZielgerÃ¤t auswÃ¤hlen" \
    --menu "WÃ¤hle das ZielgerÃ¤t (SD-Karte, USB-Stick):" 20 70 10 "${DISKS[@]}" 3>&1 1>&2 2>&3)
 
  # PrÃ¼fen, ob abgebrochen
  if [[ -z "$DEST" ]]; then
    echo "Abgebrochen."
    exit 1
  fi
fi
 
# BestÃ¤tigung anzeigen
dialog --title "BestÃ¤tigung" --yesno "Quelle: $SOURCE\nZiel: $DEST\n\nFortfahren?" 10 70
response=$?
if [[ $response -ne 0 ]]; then
  echo "Abgebrochen."
  exit 1
fi
 
# GesamtgrÃ¶ÃŸe der Input-Datei
TOTAL_SIZE=$(stat -c %s "$SOURCE")
LOGFILE="/tmp/ddd.log"
BLOCKSIZE=4M
TITLE="ğŸ“¦ DDD: Schreibe ISO"
TEXT="Kopiere '$SOURCE' nach '$DEST'..."
 
# Starte dd im Hintergrund
dd if="$SOURCE" of="$DEST" bs=$BLOCKSIZE status=progress conv=fsync 2> "$LOGFILE" &
DD_PID=$!
 
# Fortschritt anzeigen
(
  while kill -0 $DD_PID 2>/dev/null; do
    sleep 1
    CURRENT=$(grep -oP '[0-9]+ bytes' "$LOGFILE" | tail -1 | awk '{print $1}')
    if [[ -n "$CURRENT" && "$CURRENT" -gt 0 ]]; then
      PERCENT=$(( CURRENT * 100 / TOTAL_SIZE ))
      echo $PERCENT
      echo "# $TEXT ($PERCENT%)"
    fi
  done
  echo 100
  echo "# âœ… Fertig: ISO wurde erfolgreich geschrieben."
)
# | dialog --title "$TITLE" --gauge "$TEXT" 10 70 0
 
# AufrÃ¤umen
# rm -f "$LOGFILE"
 
dialog --title "Fertig" --msgbox "âœ… ISO erfolgreich geschrieben auf:\n$DEST" 10 70
 
exit 0
